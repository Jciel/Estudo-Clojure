exit
(require '[forca.core :as forca] :reload)
(forca/jogo 2 "MELANCIA" #{})
(require '[forca.core :as forca] :reload)
(forca/jogo 2 "MELANCIA" #{})
(require '[forca.core :as forca] :reload)
(forca/jogo 2 "MELANCIA" #{})
exit
(forca/jogo 2 "MELANCIA" #{})
(require '[forca.core :as forca] :reload)
(forca/jogo 2 "MELANCIA" #{})
(require '[forca.exercicios :as exercicios] :reload)
(exercicio/read-and-convert)
(exercicios/read-and-convert)
exit
(require '[forca.exercicios :as exercicios] :reload)
(forca/jogo 2 "MELANCIA" #{})
(require '[forca.core :as forca] :reload)
(forca/jogo 2 "MELANCIA" #{})
(require '[forca.core :as forca] :reload)
(forca/jogo 2 "MELANCIA" #{})
(require '[forca.core :as forca] :reload)
(forca/jogo 2 "MELANCIA" #{})
(require '[forca.core :as forca] :reload)
(forca/jogo 2 "MELANCIA" #{})
(let [y 1] 
         y)
(require '[forca.core :as forca] :reload)
(forca/jogo 2 "MELANCIA" #{})
(exit)
(+ 8 9)
(defn fib[x]
    (loop [a 1 b 1 numero 2]
        (if 
            (= numero x) b
            (recur b (+ a b) (inc numero))
        )
    ))
(fib 5)
(fib)
(fib 1)
(fib 2)
(fib 3)
(fib 4)
(fib 5)
(fib 6)
(fib 7)
(defn soma[n]
    (loop [contador 1 soma 0]
        (if (> contador n) soma
        (recur (soma (+ contador 1))))))
        (recur (soma (+ contador 1) (+ soma contador)))))
(defn soma[n]
    (loop [contador 1 soma 0]
        (if (> contador n) soma
        (recur (inc contador) (+ soma contador)))))
(soma 5)
(soma 6)
(require '[forca.core :as forca] :reload)
(forca/jogo 2 "MELANCIA" #{})
(require '[forca.core :as forca] :reload)
(forca/jogo 2 "MELANCIA" #{})
(require '[forca.core :as forca] :reload)
(forca/jogo 2 "MELANCIA" #{})
(def carros [50000.0, 60000.0])
carror
carros
(map (fn [x]
(map (fn [x] (* x 2)) carros)
(defn dobro [x]
(* x 2))
(map dobro carros)
(reduce (fn [acc n] (+ acc n)) carros)
(->> carros (map
(->> carros (map (fn [x] (* n 2))) (reduce (fn [acc n] (+ acc n))))
(->> carros (map (fn [x] (* x 2))) (reduce (fn [acc n] (+ acc n))))
(->> carros
(map (fn [x] (* x 2)))
(map (fn [x] (* x 3)))
(reduce (fn [acc n] (+ acc n))))
(map (fn [x] (* x 2)) carros)
(map (fn [x] (- x 200)) (map (fn [x] (* x 2)) carros))
(->> carros 
forca.core=> (->> carros
forca.core=> (->> carros (map (fn [x] (* x 2)))
forca.core=> (->> carros
(map (fn [x] (* x 2)))
forca.core=> (->> carros
(->> carros 
(map (fn [x] (* x 2)))
(map (fn [x] (- x 200))))
(defrecord Person [first-name last-name])
(print Person)
(def foo (->Person "Aaron" "Bedra"))
for
(foo)
#'foo
#'forca.core.foo
#'forca.core/foo
foo
foo.first-name
(foo :fist-name)
(defn hello-world [username]
(println (format "Hollo, %s" username)))
(hello-world Jociel)
(hello-world "Jociel")
(def accounts (ref #{}))
(accounts)
(print accounts)
(defrecord Account [id balance])
(dosync
(alter accounts conj (->Account "CLJ" 1000)))
(print accounts)
(->Account "Teste" 2000)
(print accounts)
(print Account)
(System/getProperties)
(/ 1 0)
(pts)
(pst)
(/ 1 0)
(pst)
#{}
(conj coll item)
(conj #{} "Stu")
(print #{})
(atom initial-state)
(def symbol initial-value?)
(quit)
